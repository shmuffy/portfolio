/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useMemo, useEffect, useState } from 'react'
import * as THREE from 'three'
import gsap from 'gsap'
import { useGSAP } from '@gsap/react'
import { useFrame } from '@react-three/fiber'
import { Float, useGLTF } from '@react-three/drei'

export default function Rubiks(props) {
    // A ref for the top-level group
    const group = useRef()

    // A ref for the literal Rubiks model so we are rotating a rotating Rubiks
    const rubiksRef = useRef()

    // Hover state
    const [hovered, setHovered] = useState(false)

    // 1) Load .glb => returns { scene, animations } (plus nodes/materials if you need them)
    const { scene, animations } = useGLTF('models/rubiks.glb')

    // 2) Create an AnimationMixer for the scene
    const mixer = useMemo(() => new THREE.AnimationMixer(scene), [scene])

    // 3) Play the built-in "Scrambling" animation (or the first clip)
    useEffect(() => {
        if (!animations.length) return
        console.log('Available animations:', animations)

        // If there's exactly one clip named "Scrambling," just take animations[0]
        const action = mixer.clipAction(animations[0])
        action.play()
    }, [animations, mixer])

    // 4) Update the mixer so the .glb’s own animation runs
    useFrame((_, delta) => mixer.update(delta))

    // 5) GSAP rotation logic (similar to your Cube.jsx code)
    //    This timeline re-runs automatically, so the cube keeps spinning.
    useGSAP(() => {
        return gsap
            .timeline({
                repeat: -1,
                repeatDelay: 0.5,
            })
            .to(rubiksRef.current.rotation, {
                // If hovered is true, spin more slowly (+2); otherwise spin full rotations
                y: hovered ? '+=2' : `+=${Math.PI * 2}`,
                x: hovered ? '+=2' : `-=${Math.PI * 2}`,
                duration: 2.5,
                // Adjust easing or any other GSAP options as you like
            })
    })

    return (
        <group ref={group} {...props} dispose={null}>
            <Float floatIntensity={2}>
                {/*
          <primitive> means we’re directly rendering the entire scene, 
          but we attach ref={rubiksRef} so GSAP can rotate it.
        */}
                <primitive
                    object={scene}
                    ref={rubiksRef}
                    // onPointerEnter / onPointerLeave to manage the hover state
                    onPointerEnter={() => setHovered(true)}
                    onPointerLeave={() => setHovered(false)}
                    // Try adjusting scale/rotation/position if needed
                    scale={9}
                />
            </Float>
        </group>
    )
}

// Preload the GLB
useGLTF.preload('models/rubiks.glb')
